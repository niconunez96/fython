<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pynction.monads.maybe API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pynction.monads.maybe</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import functools
from abc import ABC, abstractmethod, abstractproperty
from dataclasses import dataclass
from typing import Any, Callable, Generator, Generic, NoReturn, Optional, TypeVar, cast

from typing_extensions import ParamSpec

from .either import Either, Left, Right

T = TypeVar(&#34;T&#34;, covariant=True)
V = TypeVar(&#34;V&#34;, covariant=True)
L = TypeVar(&#34;L&#34;)


class Maybe(ABC, Generic[T]):
    &#34;&#34;&#34;
    Maybe monad is and abstraction over a result that could contain a value
    or not. This is specially useful to avoid any errors around `None` providing
    a useful and expressive API.

    [Maybe in Haskell](http://learnyouahaskell.com/a-fistful-of-monads#getting-our-feet-wet-with-maybe)
    &#34;&#34;&#34;

    @staticmethod
    def of(value: Optional[T]) -&gt; &#34;Maybe[T]&#34;:
        &#34;&#34;&#34;
        Returns `Nothing` instance if `value` is None, for any other case
        it returns a `Just` instance with the value provided.
        &#34;&#34;&#34;
        return Nothing.get_instance() if not value else Just(value)

    @staticmethod
    def nothing() -&gt; &#34;Nothing&#34;:
        &#34;&#34;&#34;
        Factory method for `Nothing`.
        &#34;&#34;&#34;
        return Nothing.get_instance()

    @staticmethod
    def just(value: T) -&gt; &#34;Just[T]&#34;:  # type: ignore
        &#34;&#34;&#34;
        Factory method for `Just`.
        &#34;&#34;&#34;
        return Just(value)

    @abstractproperty
    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        * Returns `True` if it&#39;s a `Nothing` instance
        * Returns `False` it it&#39;s a `Just` instance
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def map(self, f: Callable[[T], V]) -&gt; &#34;Maybe[V]&#34;:
        &#34;&#34;&#34;
        For `Just` instances, this method applies the `f` function over the value
        and
        * Returns `Nothing` if the result of the operation is None, else
        * Returns the result wrapped in a `Just` instance.

        For `Nothing` instances the `f` function is ignored.

        Example:
        ```
        just(1).map(lambda a: a + 1)  # Returns a Just(2)
        nothing.map(lambda a: a + 1)  # Returns Nothing
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def filter(self, satisfyCondition: Callable[[T], bool]) -&gt; &#34;Maybe[T]&#34;:
        &#34;&#34;&#34;
        Returns Just(value) if this is a Just and the value satisfies the given predicate.

        Example:
        ```
        just(1).filter(lambda a: a == 1)  # Returns a Just(2)
        just(1).filter(lambda a: a &gt; 1)  # Returns Nothing
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def flat_map(self, f: Callable[[T], &#34;Maybe[V]&#34;]) -&gt; &#34;Maybe[V]&#34;:
        &#34;&#34;&#34;
        For `Just` instances, this method applies the `f` function over the value.
        The difference with map is that the `f` function returns another `Maybe[V]` instead of plain `V`.

        For `Nothing` instances the `f` function is ignored.

        Example:
        ```
        just(1).flat_map(lambda a: Just(a + 1))  # Returns a Just(2)
        nothing.flat_map(lambda a: Just(a + 1))  # Returns Nothing
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def get_or_else(self, default: T) -&gt; T:  # type: ignore
        &#34;&#34;&#34;
        * Returns the value if it&#39;s a `Just` instance.
        * Returns `default` if the instance is `Nothing`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def get_or_raise(self, error: Exception) -&gt; T:
        &#34;&#34;&#34;
        * Returns the value if it&#39;s a `Just` instance.
        * Raise `error` if the instance is `Nothing`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def to_either(self, error: L) -&gt; Either[L, T]:
        &#34;&#34;&#34;
        * Returns `Left` with value `error` if it&#39;s a `Nothing` instance.
        * Returns `Right` with the same value of `Just` instance.

        Example
        ```
        just(1).to_either(&#34;ERROR&#34;)  # returns a Right(1)
        nothing.to_either(&#34;ERROR&#34;)  # returns a Left(&#34;ERROR&#34;)
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def on_empty(self, f: Callable[[], None]) -&gt; None:
        &#34;&#34;&#34;
        Runs `f` when self instance is Nothing

        Example
        ```
        just(1).on_empty(lambda: print(&#34;Hello&#34;))  # Doesn&#39;t print
        nothing.on_empty(lambda: print(&#34;Hello&#34;))  # Prints &#34;Hello&#34;
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def on_just(self, f: Callable[[], None]) -&gt; None:
        &#34;&#34;&#34;
        Runs `f` when self instance is a Just

        Example
        ```
        just(1).on_empty(lambda: print(&#34;Hello&#34;))  # Prints &#34;Hello&#34;
        nothing.on_empty(lambda: print(&#34;Hello&#34;))  # Doesn&#39;t print
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    def run(
        self,
        on_just: Callable[[], None] = None,
        on_empty: Callable[[], None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Runs `on_just` when self instance is a Just
        Runs `on_empty` when self instance is Nothing

        Example
        ```
        just(1).run(
            on_just=lambda: print(&#34;Hello&#34;),
            on_empty=lambda: print(&#34;Empty&#34;),
        )  # Prints &#34;Hello&#34;
        nothing.run(
            on_just=lambda: print(&#34;Hello&#34;),
            on_empty=lambda: print(&#34;Empty&#34;),
        )  # Prints &#34;Empty&#34;
        ```
        &#34;&#34;&#34;
        if on_empty:
            self.on_empty(on_empty)
        if on_just:
            self.on_just(on_just)


@dataclass
class Nothing(Maybe[Any]):
    _instance: Optional[&#34;Nothing&#34;] = None

    def __str__(self) -&gt; str:
        return &#34;Nothing&#34;

    @classmethod
    def get_instance(cls) -&gt; &#34;Nothing&#34;:
        if not cls._instance:
            cls._instance = Nothing()
        return cls._instance

    @property
    def is_empty(self) -&gt; bool:
        return True

    def map(self, _: Callable[[Any], Any]) -&gt; Maybe[Any]:
        return self.get_instance()

    def filter(self, _: Callable[[Any], bool]) -&gt; Maybe[Any]:
        return self

    def flat_map(self, _: Callable[[Any], Maybe[Any]]) -&gt; Maybe[Any]:
        return self

    def get_or_else(self, default: T) -&gt; T:  # type: ignore
        return default

    def get_or_raise(self, error: Exception) -&gt; NoReturn:
        raise error

    def to_either(self, error: L) -&gt; Either[L, Any]:
        return Left(error)

    def on_empty(self, f: Callable[[], None]) -&gt; None:
        f()

    def on_just(self, _: Callable[[], None]) -&gt; None:
        return


@dataclass(frozen=True)
class Just(Maybe[T]):
    _value: T

    def __str__(self) -&gt; str:
        return f&#34;Just[{self._value}]&#34;

    @property
    def is_empty(self) -&gt; bool:
        return False

    def map(self, f: Callable[[T], Optional[V]]) -&gt; Maybe[V]:
        result = f(self._value)
        if not result:
            return Nothing.get_instance()
        return Just(result)

    def filter(self, satisfyCondition: Callable[[T], bool]) -&gt; Maybe[T]:
        if satisfyCondition(self._value):
            return self
        return Nothing.get_instance()

    def flat_map(self, f: Callable[[T], Maybe[V]]) -&gt; Maybe[V]:
        return f(self._value)

    def get_or_else(self, _: Any) -&gt; T:
        return self._value

    def get_or_raise(self, _: Exception) -&gt; T:
        return self._value

    def to_either(self, _: L) -&gt; Either[L, T]:
        return Right(self._value)

    def on_empty(self, f: Callable[[], None]) -&gt; None:
        return

    def on_just(self, f: Callable[[], None]) -&gt; None:
        f()


DoMaybe = Generator[Maybe[T], T, V]
&#34;&#34;&#34;
`DoMaybe[T, V]`

This type must be used with the `@do_maybe` decorator.
This type just reflects the maybe value that is processed by the decorator.
So the `T` represents the maybe value that the do_maybe receives
and `V` is the value that is returned by the function.

Example usage:
1. The `@do_maybe` receives an Maybe of type `Maybe[User]` and then returns a `Maybe[int]`

```
@do_maybe
def example1(id: int) -&gt; DoMaybe[str, int]:
    user = yield find_user(id)
    user = yield execute_validation(user)
    return user.age
```
&#34;&#34;&#34;
DoMaybeN = DoMaybe[Any, V]
&#34;&#34;&#34;
`DoMaybeN[R1]`

This type should be used when the function that has the `do_maybe` decorator provides
more than one type for `T`.
For this type you only need to provide the value that will result after executing the function (`V`).

In order to be able to infer the different types that your function provides
you need to use a special syntax. This syntax is the conjunction of `yield from` + `_m` helper.

Example:

```
@do_maybe
def example1(id: int) -&gt; DoMaybeN[User]:
    name = yield from _m(obtain_name())  # mypy will infer &#34;name&#34; is str
    age = yield from _m(obtain_age())  # mypy will infer that &#34;age&#34; is int
    return User(name, age)
```
&#34;&#34;&#34;


def _(obj: Maybe[T]) -&gt; DoMaybeN[T]:
    &#34;&#34;&#34;
    This helper should be used along with `DoMaybeN` type. This helper
    is a workaround to allow dynamic typing in a do notation context.
    It should be used with `yield from`.

    Example:
    ```
    @do_maybe
    def example1(id: int) -&gt; DoMaybeN[User]:
        name = yield from _e(obtain_name())  # mypy will infer &#34;name&#34; is str
        age = yield from _e(obtain_age()))  # mypy will infer that &#34;age&#34; is int
        return User(name, age)
    ```
    &#34;&#34;&#34;
    a = yield obj
    return a


P = ParamSpec(&#34;P&#34;)


def do(generator: Callable[P, DoMaybe[T, V]]) -&gt; Callable[P, Maybe[V]]:
    &#34;&#34;&#34;
    `@do_maybe` is a decorator that enables the decorated function to support `do` notation
    like Haskell. [Do notation in Haskell](http://learnyouahaskell.com/a-fistful-of-monads#do-notation)

    To enable this functionality you must `yield` your either value so that the decorator function
    can have control over your flow.

    Example usage:
    1. The `@do_maybe` receives an Maybe of type `Maybe[User]` and then returns an `Maybe[str]`

        1.1 If the `@do_maybe` receives a `nothing` then the flow is cut exactly in that point
            returning a `Nothing` instance.

        1.2 If the `@do_maybe` receives a `just` the decorator will return the value
            inside of it so then your function can use it to perform anything on it.
    ```
    @do_maybe
    def example1(id: int) -&gt; DoMaybe[User, str]:
        user = yield find_user(id)
        return user.name
    ```

    Example with dynamic typing:
    ```
    @do_maybe
    def example1(id: int) -&gt; DoMaybeN[str]:
        user = yield from _m(find_user(id))  # mypy will infer that return type is User
        return user.name
    ```
    &#34;&#34;&#34;

    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Maybe[V]:
        gen = generator(*args, **kwargs)
        maybe_monad = next(gen)
        while True:
            try:
                if isinstance(maybe_monad, Nothing):
                    return Nothing.get_instance()
                maybe_monad = gen.send(cast(Just[T], maybe_monad)._value)
            except StopIteration as e:
                return Just(e.value)

    functools.update_wrapper(wrapper, generator)
    return wrapper</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pynction.monads.maybe.DoMaybe"><code class="name">var <span class="ident">DoMaybe</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pynction.monads.maybe.DoMaybe" href="#pynction.monads.maybe.DoMaybe">DoMaybe</a>[T, V]</code></p>
<p>This type must be used with the <code>@do_maybe</code> decorator.
This type just reflects the maybe value that is processed by the decorator.
So the <code>T</code> represents the maybe value that the do_maybe receives
and <code>V</code> is the value that is returned by the function.</p>
<p>Example usage:
1. The <code>@do_maybe</code> receives an Maybe of type <code><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[User]</code> and then returns a <code><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[int]</code></p>
<pre><code>@do_maybe
def example1(id: int) -&gt; DoMaybe[str, int]:
    user = yield find_user(id)
    user = yield execute_validation(user)
    return user.age
</code></pre></div>
</dd>
<dt id="pynction.monads.maybe.DoMaybeN"><code class="name">var <span class="ident">DoMaybeN</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pynction.monads.maybe.DoMaybeN" href="#pynction.monads.maybe.DoMaybeN">DoMaybeN</a>[R1]</code></p>
<p>This type should be used when the function that has the <code>do_maybe</code> decorator provides
more than one type for <code>T</code>.
For this type you only need to provide the value that will result after executing the function (<code>V</code>).</p>
<p>In order to be able to infer the different types that your function provides
you need to use a special syntax. This syntax is the conjunction of <code>yield from</code> + <code>_m</code> helper.</p>
<p>Example:</p>
<pre><code>@do_maybe
def example1(id: int) -&gt; DoMaybeN[User]:
    name = yield from _m(obtain_name())  # mypy will infer &quot;name&quot; is str
    age = yield from _m(obtain_age())  # mypy will infer that &quot;age&quot; is int
    return User(name, age)
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pynction.monads.maybe.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>generator: Callable[[~P], Generator[<a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[+T], +T, +V]]) ‑> Callable[[~P], <a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[+V]]</span>
</code></dt>
<dd>
<div class="desc"><p><code>@do_maybe</code> is a decorator that enables the decorated function to support <code><a title="pynction.monads.maybe.do" href="#pynction.monads.maybe.do">do()</a></code> notation
like Haskell. <a href="http://learnyouahaskell.com/a-fistful-of-monads#do-notation">Do notation in Haskell</a></p>
<p>To enable this functionality you must <code>yield</code> your either value so that the decorator function
can have control over your flow.</p>
<p>Example usage:
1. The <code>@do_maybe</code> receives an Maybe of type <code><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[User]</code> and then returns an <code><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[str]</code></p>
<pre><code>1.1 If the `@do_maybe` receives a &lt;code&gt;nothing&lt;/code&gt; then the flow is cut exactly in that point
    returning a &lt;code&gt;&lt;a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing"&gt;Nothing&lt;/a&gt;&lt;/code&gt; instance.

1.2 If the `@do_maybe` receives a &lt;code&gt;just&lt;/code&gt; the decorator will return the value
    inside of it so then your function can use it to perform anything on it.
</code></pre>
<pre><code>@do_maybe
def example1(id: int) -&gt; DoMaybe[User, str]:
    user = yield find_user(id)
    return user.name
</code></pre>
<p>Example with dynamic typing:</p>
<pre><code>@do_maybe
def example1(id: int) -&gt; DoMaybeN[str]:
    user = yield from _m(find_user(id))  # mypy will infer that return type is User
    return user.name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(generator: Callable[P, DoMaybe[T, V]]) -&gt; Callable[P, Maybe[V]]:
    &#34;&#34;&#34;
    `@do_maybe` is a decorator that enables the decorated function to support `do` notation
    like Haskell. [Do notation in Haskell](http://learnyouahaskell.com/a-fistful-of-monads#do-notation)

    To enable this functionality you must `yield` your either value so that the decorator function
    can have control over your flow.

    Example usage:
    1. The `@do_maybe` receives an Maybe of type `Maybe[User]` and then returns an `Maybe[str]`

        1.1 If the `@do_maybe` receives a `nothing` then the flow is cut exactly in that point
            returning a `Nothing` instance.

        1.2 If the `@do_maybe` receives a `just` the decorator will return the value
            inside of it so then your function can use it to perform anything on it.
    ```
    @do_maybe
    def example1(id: int) -&gt; DoMaybe[User, str]:
        user = yield find_user(id)
        return user.name
    ```

    Example with dynamic typing:
    ```
    @do_maybe
    def example1(id: int) -&gt; DoMaybeN[str]:
        user = yield from _m(find_user(id))  # mypy will infer that return type is User
        return user.name
    ```
    &#34;&#34;&#34;

    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Maybe[V]:
        gen = generator(*args, **kwargs)
        maybe_monad = next(gen)
        while True:
            try:
                if isinstance(maybe_monad, Nothing):
                    return Nothing.get_instance()
                maybe_monad = gen.send(cast(Just[T], maybe_monad)._value)
            except StopIteration as e:
                return Just(e.value)

    functools.update_wrapper(wrapper, generator)
    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pynction.monads.maybe.Just"><code class="flex name class">
<span>class <span class="ident">Just</span></span>
<span>(</span><span>_value: +T)</span>
</code></dt>
<dd>
<div class="desc"><p>Just(<em>args, </em>*kwds)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Just(Maybe[T]):
    _value: T

    def __str__(self) -&gt; str:
        return f&#34;Just[{self._value}]&#34;

    @property
    def is_empty(self) -&gt; bool:
        return False

    def map(self, f: Callable[[T], Optional[V]]) -&gt; Maybe[V]:
        result = f(self._value)
        if not result:
            return Nothing.get_instance()
        return Just(result)

    def filter(self, satisfyCondition: Callable[[T], bool]) -&gt; Maybe[T]:
        if satisfyCondition(self._value):
            return self
        return Nothing.get_instance()

    def flat_map(self, f: Callable[[T], Maybe[V]]) -&gt; Maybe[V]:
        return f(self._value)

    def get_or_else(self, _: Any) -&gt; T:
        return self._value

    def get_or_raise(self, _: Exception) -&gt; T:
        return self._value

    def to_either(self, _: L) -&gt; Either[L, T]:
        return Right(self._value)

    def on_empty(self, f: Callable[[], None]) -&gt; None:
        return

    def on_just(self, f: Callable[[], None]) -&gt; None:
        f()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a></b></code>:
<ul class="hlist">
<li><code><a title="pynction.monads.maybe.Maybe.filter" href="#pynction.monads.maybe.Maybe.filter">filter</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.flat_map" href="#pynction.monads.maybe.Maybe.flat_map">flat_map</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.get_or_else" href="#pynction.monads.maybe.Maybe.get_or_else">get_or_else</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.get_or_raise" href="#pynction.monads.maybe.Maybe.get_or_raise">get_or_raise</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.is_empty" href="#pynction.monads.maybe.Maybe.is_empty">is_empty</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.just" href="#pynction.monads.maybe.Maybe.just">just</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.map" href="#pynction.monads.maybe.Maybe.map">map</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.nothing" href="#pynction.monads.maybe.Maybe.nothing">nothing</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.of" href="#pynction.monads.maybe.Maybe.of">of</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.on_empty" href="#pynction.monads.maybe.Maybe.on_empty">on_empty</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.on_just" href="#pynction.monads.maybe.Maybe.on_just">on_just</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.run" href="#pynction.monads.maybe.Maybe.run">run</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.to_either" href="#pynction.monads.maybe.Maybe.to_either">to_either</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pynction.monads.maybe.Maybe"><code class="flex name class">
<span>class <span class="ident">Maybe</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Maybe monad is and abstraction over a result that could contain a value
or not. This is specially useful to avoid any errors around <code>None</code> providing
a useful and expressive API.</p>
<p><a href="http://learnyouahaskell.com/a-fistful-of-monads#getting-our-feet-wet-with-maybe">Maybe in Haskell</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Maybe(ABC, Generic[T]):
    &#34;&#34;&#34;
    Maybe monad is and abstraction over a result that could contain a value
    or not. This is specially useful to avoid any errors around `None` providing
    a useful and expressive API.

    [Maybe in Haskell](http://learnyouahaskell.com/a-fistful-of-monads#getting-our-feet-wet-with-maybe)
    &#34;&#34;&#34;

    @staticmethod
    def of(value: Optional[T]) -&gt; &#34;Maybe[T]&#34;:
        &#34;&#34;&#34;
        Returns `Nothing` instance if `value` is None, for any other case
        it returns a `Just` instance with the value provided.
        &#34;&#34;&#34;
        return Nothing.get_instance() if not value else Just(value)

    @staticmethod
    def nothing() -&gt; &#34;Nothing&#34;:
        &#34;&#34;&#34;
        Factory method for `Nothing`.
        &#34;&#34;&#34;
        return Nothing.get_instance()

    @staticmethod
    def just(value: T) -&gt; &#34;Just[T]&#34;:  # type: ignore
        &#34;&#34;&#34;
        Factory method for `Just`.
        &#34;&#34;&#34;
        return Just(value)

    @abstractproperty
    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        * Returns `True` if it&#39;s a `Nothing` instance
        * Returns `False` it it&#39;s a `Just` instance
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def map(self, f: Callable[[T], V]) -&gt; &#34;Maybe[V]&#34;:
        &#34;&#34;&#34;
        For `Just` instances, this method applies the `f` function over the value
        and
        * Returns `Nothing` if the result of the operation is None, else
        * Returns the result wrapped in a `Just` instance.

        For `Nothing` instances the `f` function is ignored.

        Example:
        ```
        just(1).map(lambda a: a + 1)  # Returns a Just(2)
        nothing.map(lambda a: a + 1)  # Returns Nothing
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def filter(self, satisfyCondition: Callable[[T], bool]) -&gt; &#34;Maybe[T]&#34;:
        &#34;&#34;&#34;
        Returns Just(value) if this is a Just and the value satisfies the given predicate.

        Example:
        ```
        just(1).filter(lambda a: a == 1)  # Returns a Just(2)
        just(1).filter(lambda a: a &gt; 1)  # Returns Nothing
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def flat_map(self, f: Callable[[T], &#34;Maybe[V]&#34;]) -&gt; &#34;Maybe[V]&#34;:
        &#34;&#34;&#34;
        For `Just` instances, this method applies the `f` function over the value.
        The difference with map is that the `f` function returns another `Maybe[V]` instead of plain `V`.

        For `Nothing` instances the `f` function is ignored.

        Example:
        ```
        just(1).flat_map(lambda a: Just(a + 1))  # Returns a Just(2)
        nothing.flat_map(lambda a: Just(a + 1))  # Returns Nothing
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def get_or_else(self, default: T) -&gt; T:  # type: ignore
        &#34;&#34;&#34;
        * Returns the value if it&#39;s a `Just` instance.
        * Returns `default` if the instance is `Nothing`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def get_or_raise(self, error: Exception) -&gt; T:
        &#34;&#34;&#34;
        * Returns the value if it&#39;s a `Just` instance.
        * Raise `error` if the instance is `Nothing`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def to_either(self, error: L) -&gt; Either[L, T]:
        &#34;&#34;&#34;
        * Returns `Left` with value `error` if it&#39;s a `Nothing` instance.
        * Returns `Right` with the same value of `Just` instance.

        Example
        ```
        just(1).to_either(&#34;ERROR&#34;)  # returns a Right(1)
        nothing.to_either(&#34;ERROR&#34;)  # returns a Left(&#34;ERROR&#34;)
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def on_empty(self, f: Callable[[], None]) -&gt; None:
        &#34;&#34;&#34;
        Runs `f` when self instance is Nothing

        Example
        ```
        just(1).on_empty(lambda: print(&#34;Hello&#34;))  # Doesn&#39;t print
        nothing.on_empty(lambda: print(&#34;Hello&#34;))  # Prints &#34;Hello&#34;
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def on_just(self, f: Callable[[], None]) -&gt; None:
        &#34;&#34;&#34;
        Runs `f` when self instance is a Just

        Example
        ```
        just(1).on_empty(lambda: print(&#34;Hello&#34;))  # Prints &#34;Hello&#34;
        nothing.on_empty(lambda: print(&#34;Hello&#34;))  # Doesn&#39;t print
        ```
        &#34;&#34;&#34;
        raise NotImplementedError

    def run(
        self,
        on_just: Callable[[], None] = None,
        on_empty: Callable[[], None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Runs `on_just` when self instance is a Just
        Runs `on_empty` when self instance is Nothing

        Example
        ```
        just(1).run(
            on_just=lambda: print(&#34;Hello&#34;),
            on_empty=lambda: print(&#34;Empty&#34;),
        )  # Prints &#34;Hello&#34;
        nothing.run(
            on_just=lambda: print(&#34;Hello&#34;),
            on_empty=lambda: print(&#34;Empty&#34;),
        )  # Prints &#34;Empty&#34;
        ```
        &#34;&#34;&#34;
        if on_empty:
            self.on_empty(on_empty)
        if on_just:
            self.on_just(on_just)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></li>
<li><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pynction.monads.maybe.Maybe.just"><code class="name flex">
<span>def <span class="ident">just</span></span>(<span>value: +T) ‑> <a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a>[+T]</span>
</code></dt>
<dd>
<div class="desc"><p>Factory method for <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def just(value: T) -&gt; &#34;Just[T]&#34;:  # type: ignore
    &#34;&#34;&#34;
    Factory method for `Just`.
    &#34;&#34;&#34;
    return Just(value)</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.nothing"><code class="name flex">
<span>def <span class="ident">nothing</span></span>(<span>) ‑> <a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></span>
</code></dt>
<dd>
<div class="desc"><p>Factory method for <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def nothing() -&gt; &#34;Nothing&#34;:
    &#34;&#34;&#34;
    Factory method for `Nothing`.
    &#34;&#34;&#34;
    return Nothing.get_instance()</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>value: Optional[+T]) ‑> <a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[+T]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code> instance if <code>value</code> is None, for any other case
it returns a <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code> instance with the value provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of(value: Optional[T]) -&gt; &#34;Maybe[T]&#34;:
    &#34;&#34;&#34;
    Returns `Nothing` instance if `value` is None, for any other case
    it returns a `Just` instance with the value provided.
    &#34;&#34;&#34;
    return Nothing.get_instance() if not value else Just(value)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pynction.monads.maybe.Maybe.is_empty"><code class="name">var <span class="ident">is_empty</span> : bool</code></dt>
<dd>
<div class="desc"><ul>
<li>Returns <code>True</code> if it's a <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code> instance</li>
<li>Returns <code>False</code> it it's a <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code> instance</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractproperty
def is_empty(self) -&gt; bool:
    &#34;&#34;&#34;
    * Returns `True` if it&#39;s a `Nothing` instance
    * Returns `False` it it&#39;s a `Just` instance
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pynction.monads.maybe.Maybe.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, satisfyCondition: Callable[[+T], bool]) ‑> <a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[+T]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Just(value) if this is a Just and the value satisfies the given predicate.</p>
<p>Example:</p>
<pre><code>just(1).filter(lambda a: a == 1)  # Returns a Just(2)
just(1).filter(lambda a: a &gt; 1)  # Returns Nothing
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def filter(self, satisfyCondition: Callable[[T], bool]) -&gt; &#34;Maybe[T]&#34;:
    &#34;&#34;&#34;
    Returns Just(value) if this is a Just and the value satisfies the given predicate.

    Example:
    ```
    just(1).filter(lambda a: a == 1)  # Returns a Just(2)
    just(1).filter(lambda a: a &gt; 1)  # Returns Nothing
    ```
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.flat_map"><code class="name flex">
<span>def <span class="ident">flat_map</span></span>(<span>self, f: Callable[[+T], ForwardRef('<a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[V]')]) ‑> <a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[+V]</span>
</code></dt>
<dd>
<div class="desc"><p>For <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code> instances, this method applies the <code>f</code> function over the value.
The difference with map is that the <code>f</code> function returns another <code><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[V]</code> instead of plain <code>V</code>.</p>
<p>For <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code> instances the <code>f</code> function is ignored.</p>
<p>Example:</p>
<pre><code>just(1).flat_map(lambda a: Just(a + 1))  # Returns a Just(2)
nothing.flat_map(lambda a: Just(a + 1))  # Returns Nothing
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def flat_map(self, f: Callable[[T], &#34;Maybe[V]&#34;]) -&gt; &#34;Maybe[V]&#34;:
    &#34;&#34;&#34;
    For `Just` instances, this method applies the `f` function over the value.
    The difference with map is that the `f` function returns another `Maybe[V]` instead of plain `V`.

    For `Nothing` instances the `f` function is ignored.

    Example:
    ```
    just(1).flat_map(lambda a: Just(a + 1))  # Returns a Just(2)
    nothing.flat_map(lambda a: Just(a + 1))  # Returns Nothing
    ```
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.get_or_else"><code class="name flex">
<span>def <span class="ident">get_or_else</span></span>(<span>self, default: +T) ‑> +T</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>Returns the value if it's a <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code> instance.</li>
<li>Returns <code>default</code> if the instance is <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_or_else(self, default: T) -&gt; T:  # type: ignore
    &#34;&#34;&#34;
    * Returns the value if it&#39;s a `Just` instance.
    * Returns `default` if the instance is `Nothing`.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.get_or_raise"><code class="name flex">
<span>def <span class="ident">get_or_raise</span></span>(<span>self, error: Exception) ‑> +T</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>Returns the value if it's a <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code> instance.</li>
<li>Raise <code>error</code> if the instance is <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_or_raise(self, error: Exception) -&gt; T:
    &#34;&#34;&#34;
    * Returns the value if it&#39;s a `Just` instance.
    * Raise `error` if the instance is `Nothing`.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f: Callable[[+T], +V]) ‑> <a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a>[+V]</span>
</code></dt>
<dd>
<div class="desc"><p>For <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code> instances, this method applies the <code>f</code> function over the value
and
* Returns <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code> if the result of the operation is None, else
* Returns the result wrapped in a <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code> instance.</p>
<p>For <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code> instances the <code>f</code> function is ignored.</p>
<p>Example:</p>
<pre><code>just(1).map(lambda a: a + 1)  # Returns a Just(2)
nothing.map(lambda a: a + 1)  # Returns Nothing
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def map(self, f: Callable[[T], V]) -&gt; &#34;Maybe[V]&#34;:
    &#34;&#34;&#34;
    For `Just` instances, this method applies the `f` function over the value
    and
    * Returns `Nothing` if the result of the operation is None, else
    * Returns the result wrapped in a `Just` instance.

    For `Nothing` instances the `f` function is ignored.

    Example:
    ```
    just(1).map(lambda a: a + 1)  # Returns a Just(2)
    nothing.map(lambda a: a + 1)  # Returns Nothing
    ```
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.on_empty"><code class="name flex">
<span>def <span class="ident">on_empty</span></span>(<span>self, f: Callable[[], None]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Runs <code>f</code> when self instance is Nothing</p>
<p>Example</p>
<pre><code>just(1).on_empty(lambda: print(&quot;Hello&quot;))  # Doesn't print
nothing.on_empty(lambda: print(&quot;Hello&quot;))  # Prints &quot;Hello&quot;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def on_empty(self, f: Callable[[], None]) -&gt; None:
    &#34;&#34;&#34;
    Runs `f` when self instance is Nothing

    Example
    ```
    just(1).on_empty(lambda: print(&#34;Hello&#34;))  # Doesn&#39;t print
    nothing.on_empty(lambda: print(&#34;Hello&#34;))  # Prints &#34;Hello&#34;
    ```
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.on_just"><code class="name flex">
<span>def <span class="ident">on_just</span></span>(<span>self, f: Callable[[], None]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Runs <code>f</code> when self instance is a Just</p>
<p>Example</p>
<pre><code>just(1).on_empty(lambda: print(&quot;Hello&quot;))  # Prints &quot;Hello&quot;
nothing.on_empty(lambda: print(&quot;Hello&quot;))  # Doesn't print
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def on_just(self, f: Callable[[], None]) -&gt; None:
    &#34;&#34;&#34;
    Runs `f` when self instance is a Just

    Example
    ```
    just(1).on_empty(lambda: print(&#34;Hello&#34;))  # Prints &#34;Hello&#34;
    nothing.on_empty(lambda: print(&#34;Hello&#34;))  # Doesn&#39;t print
    ```
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, on_just: Callable[[], None] = None, on_empty: Callable[[], None] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Runs <code>on_just</code> when self instance is a Just
Runs <code>on_empty</code> when self instance is Nothing</p>
<p>Example</p>
<pre><code>just(1).run(
    on_just=lambda: print(&quot;Hello&quot;),
    on_empty=lambda: print(&quot;Empty&quot;),
)  # Prints &quot;Hello&quot;
nothing.run(
    on_just=lambda: print(&quot;Hello&quot;),
    on_empty=lambda: print(&quot;Empty&quot;),
)  # Prints &quot;Empty&quot;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(
    self,
    on_just: Callable[[], None] = None,
    on_empty: Callable[[], None] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Runs `on_just` when self instance is a Just
    Runs `on_empty` when self instance is Nothing

    Example
    ```
    just(1).run(
        on_just=lambda: print(&#34;Hello&#34;),
        on_empty=lambda: print(&#34;Empty&#34;),
    )  # Prints &#34;Hello&#34;
    nothing.run(
        on_just=lambda: print(&#34;Hello&#34;),
        on_empty=lambda: print(&#34;Empty&#34;),
    )  # Prints &#34;Empty&#34;
    ```
    &#34;&#34;&#34;
    if on_empty:
        self.on_empty(on_empty)
    if on_just:
        self.on_just(on_just)</code></pre>
</details>
</dd>
<dt id="pynction.monads.maybe.Maybe.to_either"><code class="name flex">
<span>def <span class="ident">to_either</span></span>(<span>self, error: ~L) ‑> <a title="pynction.monads.either.Either" href="either.html#pynction.monads.either.Either">Either</a>[~L, +T]</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>Returns <code>Left</code> with value <code>error</code> if it's a <code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code> instance.</li>
<li>Returns <code>Right</code> with the same value of <code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code> instance.</li>
</ul>
<p>Example</p>
<pre><code>just(1).to_either(&quot;ERROR&quot;)  # returns a Right(1)
nothing.to_either(&quot;ERROR&quot;)  # returns a Left(&quot;ERROR&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_either(self, error: L) -&gt; Either[L, T]:
    &#34;&#34;&#34;
    * Returns `Left` with value `error` if it&#39;s a `Nothing` instance.
    * Returns `Right` with the same value of `Just` instance.

    Example
    ```
    just(1).to_either(&#34;ERROR&#34;)  # returns a Right(1)
    nothing.to_either(&#34;ERROR&#34;)  # returns a Left(&#34;ERROR&#34;)
    ```
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pynction.monads.maybe.Nothing"><code class="flex name class">
<span>class <span class="ident">Nothing</span></span>
</code></dt>
<dd>
<div class="desc"><p>Nothing(<em>args, </em>*kwds)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Nothing(Maybe[Any]):
    _instance: Optional[&#34;Nothing&#34;] = None

    def __str__(self) -&gt; str:
        return &#34;Nothing&#34;

    @classmethod
    def get_instance(cls) -&gt; &#34;Nothing&#34;:
        if not cls._instance:
            cls._instance = Nothing()
        return cls._instance

    @property
    def is_empty(self) -&gt; bool:
        return True

    def map(self, _: Callable[[Any], Any]) -&gt; Maybe[Any]:
        return self.get_instance()

    def filter(self, _: Callable[[Any], bool]) -&gt; Maybe[Any]:
        return self

    def flat_map(self, _: Callable[[Any], Maybe[Any]]) -&gt; Maybe[Any]:
        return self

    def get_or_else(self, default: T) -&gt; T:  # type: ignore
        return default

    def get_or_raise(self, error: Exception) -&gt; NoReturn:
        raise error

    def to_either(self, error: L) -&gt; Either[L, Any]:
        return Left(error)

    def on_empty(self, f: Callable[[], None]) -&gt; None:
        f()

    def on_just(self, _: Callable[[], None]) -&gt; None:
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pynction.monads.maybe.Nothing.get_instance"><code class="name flex">
<span>def <span class="ident">get_instance</span></span>(<span>) ‑> <a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_instance(cls) -&gt; &#34;Nothing&#34;:
    if not cls._instance:
        cls._instance = Nothing()
    return cls._instance</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a></b></code>:
<ul class="hlist">
<li><code><a title="pynction.monads.maybe.Maybe.filter" href="#pynction.monads.maybe.Maybe.filter">filter</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.flat_map" href="#pynction.monads.maybe.Maybe.flat_map">flat_map</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.get_or_else" href="#pynction.monads.maybe.Maybe.get_or_else">get_or_else</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.get_or_raise" href="#pynction.monads.maybe.Maybe.get_or_raise">get_or_raise</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.is_empty" href="#pynction.monads.maybe.Maybe.is_empty">is_empty</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.just" href="#pynction.monads.maybe.Maybe.just">just</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.map" href="#pynction.monads.maybe.Maybe.map">map</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.nothing" href="#pynction.monads.maybe.Maybe.nothing">nothing</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.of" href="#pynction.monads.maybe.Maybe.of">of</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.on_empty" href="#pynction.monads.maybe.Maybe.on_empty">on_empty</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.on_just" href="#pynction.monads.maybe.Maybe.on_just">on_just</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.run" href="#pynction.monads.maybe.Maybe.run">run</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.to_either" href="#pynction.monads.maybe.Maybe.to_either">to_either</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pynction.monads" href="index.html">pynction.monads</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pynction.monads.maybe.DoMaybe" href="#pynction.monads.maybe.DoMaybe">DoMaybe</a></code></li>
<li><code><a title="pynction.monads.maybe.DoMaybeN" href="#pynction.monads.maybe.DoMaybeN">DoMaybeN</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pynction.monads.maybe.do" href="#pynction.monads.maybe.do">do</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pynction.monads.maybe.Just" href="#pynction.monads.maybe.Just">Just</a></code></h4>
</li>
<li>
<h4><code><a title="pynction.monads.maybe.Maybe" href="#pynction.monads.maybe.Maybe">Maybe</a></code></h4>
<ul class="two-column">
<li><code><a title="pynction.monads.maybe.Maybe.filter" href="#pynction.monads.maybe.Maybe.filter">filter</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.flat_map" href="#pynction.monads.maybe.Maybe.flat_map">flat_map</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.get_or_else" href="#pynction.monads.maybe.Maybe.get_or_else">get_or_else</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.get_or_raise" href="#pynction.monads.maybe.Maybe.get_or_raise">get_or_raise</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.is_empty" href="#pynction.monads.maybe.Maybe.is_empty">is_empty</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.just" href="#pynction.monads.maybe.Maybe.just">just</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.map" href="#pynction.monads.maybe.Maybe.map">map</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.nothing" href="#pynction.monads.maybe.Maybe.nothing">nothing</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.of" href="#pynction.monads.maybe.Maybe.of">of</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.on_empty" href="#pynction.monads.maybe.Maybe.on_empty">on_empty</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.on_just" href="#pynction.monads.maybe.Maybe.on_just">on_just</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.run" href="#pynction.monads.maybe.Maybe.run">run</a></code></li>
<li><code><a title="pynction.monads.maybe.Maybe.to_either" href="#pynction.monads.maybe.Maybe.to_either">to_either</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pynction.monads.maybe.Nothing" href="#pynction.monads.maybe.Nothing">Nothing</a></code></h4>
<ul class="">
<li><code><a title="pynction.monads.maybe.Nothing.get_instance" href="#pynction.monads.maybe.Nothing.get_instance">get_instance</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
